#!/bin/bash

###############################################################################
# MyNodeOne - Main Installation Script
# 
# This is the ONE script users run. It handles everything:
# - System cleanup
# - Disk detection and setup
# - Interactive configuration
# - Node type selection
# - Automated deployment
###############################################################################

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Track if we're in the middle of critical operations
CRITICAL_OPERATION=false

# Cleanup function for interrupt handling
cleanup_on_interrupt() {
    echo
    echo
    print_error "Installation interrupted by user (Ctrl+C)"
    echo
    
    if [ "$CRITICAL_OPERATION" = true ]; then
        print_warning "Interrupted during a critical operation!"
        echo "Your system may be in an inconsistent state."
        echo
        echo "To recover:"
        echo "  1. Check what was being done (see messages above)"
        echo "  2. Manually undo any partial changes if needed"
        echo "  3. Run the script again to restart"
    else
        print_info "No critical operations were in progress."
        echo "You can safely run the script again."
    fi
    
    echo
    exit 130
}

# Set up interrupt handling
trap cleanup_on_interrupt INT TERM

# Helper functions
print_header() {
    echo
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

prompt_confirm() {
    local prompt="$1"
    local default="${2:-n}"
    local response
    
    if [ "$default" = "y" ]; then
        read -p "$(echo -e ${GREEN}?${NC}) $prompt [Y/n]: " response
        response="${response:-y}"
    else
        read -p "$(echo -e ${GREEN}?${NC}) $prompt [y/N]: " response
        response="${response:-n}"
    fi
    
    [[ "$response" =~ ^[Yy]$ ]]
}

welcome() {
    clear
    echo -e "${MAGENTA}"
    cat << "EOF"
   __  ___       _   __          __     ____             
  /  |/  /_  __/ | / /___  ____/ /__  / __ \____  _____ 
 / /|_/ / / / /  |/ / __ \/ __  / _ \/ / / / __ \/ _ \  
/ /  / / /_/ / /|  / /_/ / /_/ /  __/ /_/ / / / /  __/  
/_/  /_/\__, /_/ |_/\____/\__,_/\___/\____/_/ /_/\___/   
       /____/ 
                                                 
EOF
    echo -e "${NC}"
    echo -e "${CYAN}Welcome to MyNodeOne Setup!${NC}"
    echo
    echo "This script will help you set up your private cloud infrastructure."
    echo "It handles everything automatically:"
    echo
    echo "  ✓ System optimization"
    echo "  ✓ Disk detection and setup"
    echo "  ✓ Network configuration"
    echo "  ✓ Service installation"
    echo
    echo -e "${YELLOW}Note: This script requires sudo/root access.${NC}"
    echo
    
    if ! prompt_confirm "Ready to start?" "y"; then
        echo "Setup cancelled."
        exit 0
    fi
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        print_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

check_network() {
    print_info "Checking internet connectivity..."
    
    if ! ping -c 1 -W 5 8.8.8.8 &> /dev/null; then
        print_error "No internet connection detected"
        echo
        echo "MyNodeOne requires internet access to download components."
        echo "Please check your network connection and try again."
        echo
        echo "Troubleshooting:"
        echo "  1. Check if network cable is connected"
        echo "  2. Try: ping 8.8.8.8"
        echo "  3. Check firewall settings"
        return 1
    fi
    
    if ! ping -c 1 -W 5 github.com &> /dev/null; then
        print_warning "Can reach internet but not GitHub"
        echo "This might cause issues downloading from GitHub."
        if ! prompt_confirm "Continue anyway?"; then
            return 1
        fi
    fi
    
    print_success "Internet connection OK"
    return 0
}

check_dependencies() {
    print_info "Checking required dependencies..."
    
    local deps=("curl" "wget" "git" "lsblk" "mkfs.ext4" "blkid" "awk" "grep")
    local missing=()
    
    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        print_error "Missing required dependencies: ${missing[*]}"
        echo
        echo "Install with:"
        echo "  sudo apt-get update"
        echo "  sudo apt-get install -y ${missing[*]}"
        return 1
    fi
    
    print_success "All dependencies present"
    return 0
}

check_architecture() {
    print_info "Detecting system architecture..."
    
    local arch=$(uname -m)
    case $arch in
        x86_64)
            print_success "Architecture: x86_64 (AMD64)"
            ;;
        aarch64)
            print_success "Architecture: aarch64 (ARM64)"
            ;;
        armv7l)
            print_success "Architecture: armv7l (ARM)"
            ;;
        *)
            print_warning "Architecture: $arch (may not be fully tested)"
            ;;
    esac
}

check_distro() {
    print_info "Checking Linux distribution..."
    
    if [ -f /etc/os-release ]; then
        source /etc/os-release
        
        if [[ "$ID" == "ubuntu" ]]; then
            if [[ "$VERSION_ID" == "24.04" ]]; then
                print_success "Ubuntu 24.04 LTS detected (recommended)"
            elif [[ "$VERSION_ID" == "22.04" ]]; then
                print_success "Ubuntu 22.04 LTS detected (supported)"
            else
                print_warning "Ubuntu $VERSION_ID detected (not officially tested)"
                if ! prompt_confirm "Continue anyway?"; then
                    exit 1
                fi
            fi
        else
            print_warning "Non-Ubuntu distribution detected: $NAME $VERSION_ID"
            echo "MyNodeOne is optimized for Ubuntu 24.04 LTS."
            if ! prompt_confirm "Continue anyway?"; then
                exit 1
            fi
        fi
    else
        print_warning "Cannot detect distribution"
        if ! prompt_confirm "Continue anyway?"; then
            exit 1
        fi
    fi
}

check_system_resources() {
    print_info "Validating system resources..."
    
    # Check RAM
    local ram_gb=$(free -g | awk '/^Mem:/{print $2}')
    local min_ram=4
    
    if [ "$ram_gb" -lt "$min_ram" ]; then
        print_error "Insufficient RAM: ${ram_gb}GB (minimum ${min_ram}GB required for control plane)"
        echo
        echo "Your system has ${ram_gb}GB RAM, but control plane requires at least ${min_ram}GB."
        echo
        echo "Options:"
        echo "  1. Add more RAM to this machine"
        echo "  2. Use this as a worker node instead (requires 2GB minimum)"
        echo "  3. Use a different machine with more RAM"
        return 1
    fi
    
    # Check disk space
    local disk_gb=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
    local min_disk=20
    
    if [ "$disk_gb" -lt "$min_disk" ]; then
        print_error "Insufficient disk space: ${disk_gb}GB available (minimum ${min_disk}GB required)"
        echo
        echo "Free up space with:"
        echo "  sudo apt-get clean"
        echo "  sudo apt-get autoremove"
        echo "  sudo journalctl --vacuum-time=7d"
        echo
        return 1
    fi
    
    # Check CPU cores
    local cpu_cores=$(nproc)
    local min_cores=2
    
    if [ "$cpu_cores" -lt "$min_cores" ]; then
        print_warning "Low CPU cores: ${cpu_cores} (recommended ${min_cores}+ for smooth operation)"
        echo "Installation will proceed but performance may be limited."
        if ! prompt_confirm "Continue anyway?"; then
            return 1
        fi
    fi
    
    print_success "System resources OK: ${ram_gb}GB RAM, ${disk_gb}GB free disk, ${cpu_cores} CPU cores"
    return 0
}

check_existing_installation() {
    if [ -f "$HOME/.mynodeone/config.env" ]; then
        print_warning "MyNodeOne appears to be already configured"
        echo
        echo "Existing configuration found at: $HOME/.mynodeone/config.env"
        echo
        echo "Options:"
        echo "  1) Reconfigure (update configuration, keep existing setup)"
        echo "  2) Reinstall (remove everything, fresh start)"
        echo "  3) Cancel"
        echo
        read -p "Select option (1-3): " option
        
        case $option in
            1)
                print_info "Reconfiguring..."
                return 0
                ;;
            2)
                print_warning "This will remove existing MyNodeOne installation"
                if prompt_confirm "Are you sure you want to reinstall?"; then
                    # Backup existing config
                    cp "$HOME/.mynodeone/config.env" "$HOME/.mynodeone/config.env.backup-$(date +%Y%m%d-%H%M%S)"
                    print_info "Config backed up. Proceeding with reinstall..."
                    return 0
                else
                    exit 0
                fi
                ;;
            3)
                print_info "Installation cancelled"
                exit 0
                ;;
            *)
                print_error "Invalid option"
                exit 1
                ;;
        esac
    fi
}

system_cleanup() {
    print_header "System Cleanup & Optimization"
    
    if prompt_confirm "Clean up unnecessary packages?"; then
        print_info "Removing unnecessary packages..."
        
        # WARNING: DO NOT remove snap - it's required for tools like Helm
        # Snap removal can break Firefox, Helm, and other critical tools
        # Keeping snap check disabled for safety
        
        # Remove unnecessary packages
        print_info "Removing unnecessary packages..."
        apt-get autoremove -y
        apt-get autoclean -y
        
        # Clean apt cache
        apt-get clean
        
        # Remove old kernels (keep current + 1)
        print_info "Cleaning old kernels..."
        apt-get autoremove --purge -y
        
        print_success "System cleanup complete"
    else
        print_info "Skipping system cleanup"
    fi
}

detect_disks() {
    print_header "Disk Detection"
    
    print_info "Scanning for available disks..."
    echo
    
    # ===================================================================
    # CRITICAL SAFETY: Identify the OS disk (where root / is mounted)
    # ===================================================================
    
    # Find the device where root (/) is mounted
    ROOT_DEVICE=$(df / | tail -1 | awk '{print $1}')
    
    # Extract the base disk name (remove partition number)
    # Examples: /dev/sda1 -> /dev/sda, /dev/nvme0n1p1 -> /dev/nvme0n1
    if [[ "$ROOT_DEVICE" =~ ^/dev/(sd[a-z])[0-9]+$ ]]; then
        OS_DISK="/dev/${BASH_REMATCH[1]}"
    elif [[ "$ROOT_DEVICE" =~ ^/dev/(nvme[0-9]+n[0-9]+)p[0-9]+$ ]]; then
        OS_DISK="/dev/${BASH_REMATCH[1]}"
    elif [[ "$ROOT_DEVICE" =~ ^/dev/(mmcblk[0-9]+)p[0-9]+$ ]]; then
        OS_DISK="/dev/${BASH_REMATCH[1]}"
    else
        # Fallback: just remove the last digit
        OS_DISK=$(echo "$ROOT_DEVICE" | sed 's/[0-9]*$//')
    fi
    
    print_info "OS (Ubuntu) is installed on: $OS_DISK"
    print_warning "This disk will be EXCLUDED from storage setup for safety"
    echo
    
    # List all block devices with highlighting
    echo "Current disk layout:"
    lsblk -o NAME,SIZE,TYPE,MOUNTPOINT,FSTYPE | grep -E "disk|part" | while read -r line; do
        if echo "$line" | grep -q "$(basename "$OS_DISK")"; then
            echo -e "${RED}$line${NC} ${YELLOW}← OS DISK (PROTECTED)${NC}"
        else
            echo "$line"
        fi
    done
    echo
    
    # ===================================================================
    # SAFE DISK DETECTION: Only show disks that are:
    # 1. NOT the OS disk
    # 2. Have NO mounted partitions
    # 3. Are actual disks (not loop devices, not partitions)
    # ===================================================================
    
    UNMOUNTED_DISKS=()
    
    # Get list of all disks (not partitions)
    while IFS= read -r disk_name; do
        DISK="/dev/$disk_name"
        
        # Skip the OS disk - CRITICAL!
        if [ "$DISK" = "$OS_DISK" ]; then
            continue
        fi
        
        # Check if this disk has ANY mounted partitions
        # Note: We'll allow disks with mounted partitions but will unmount them before formatting
        UNMOUNTED_DISKS+=("$DISK")
    done < <(lsblk -n -d -o NAME,TYPE | grep "disk" | awk '{print $1}')
    
    if [ ${#UNMOUNTED_DISKS[@]} -eq 0 ]; then
        print_info "No additional unmounted disks detected (only OS disk found)."
        print_info "If you have additional disks, ensure they are physically connected and powered on."
        return
    fi
    
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    print_warning "Found ${#UNMOUNTED_DISKS[@]} SAFE disk(s) for storage:"
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        SIZE=$(lsblk -n -o SIZE "$disk" | head -1)
        MODEL=$(lsblk -n -o MODEL "$disk" | head -1 | xargs)
        echo "  ✓ $disk ($SIZE) ${MODEL:+- $MODEL}"
    done
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    
    echo -e "${YELLOW}⚠️  IMPORTANT SAFETY INFORMATION:${NC}"
    echo "  • OS disk ($OS_DISK) is EXCLUDED for safety"
    echo "  • Only disks with NO mounted partitions are shown"
    echo "  • Formatting will ERASE ALL DATA on selected disks"
    echo
    
    if prompt_confirm "Do you want to set up these disks for MyNodeOne storage?"; then
        select_disks_for_setup
    fi
}

select_disks_for_setup() {
    print_header "Disk Selection"
    
    # Let user choose which disks to use
    echo "You can choose to use:"
    echo "  1) All detected disks (${#UNMOUNTED_DISKS[@]} disks)"
    echo "  2) Select specific disks individually"
    echo "  3) Skip disk setup (configure later)"
    echo
    
    read -p "$(echo -e ${GREEN}?${NC}) Select option (1-3): " SELECTION_OPTION
    
    case $SELECTION_OPTION in
        1)
            # Use all disks
            SELECTED_DISKS=("${UNMOUNTED_DISKS[@]}")
            print_success "All ${#SELECTED_DISKS[@]} disks selected"
            echo
            for disk in "${SELECTED_DISKS[@]}"; do
                SIZE=$(lsblk -n -o SIZE "$disk" | head -1)
                echo "  ✓ $disk ($SIZE)"
            done
            echo
            setup_disks
            ;;
        2)
            # Let user select specific disks
            select_individual_disks
            ;;
        3)
            print_info "Skipping disk setup. You can configure storage later."
            return
            ;;
        *)
            print_error "Invalid option"
            select_disks_for_setup
            ;;
    esac
}

select_individual_disks() {
    print_header "Individual Disk Selection"
    
    SELECTED_DISKS=()
    
    echo "Select which disks you want to use for MyNodeOne storage."
    echo "You can choose one, some, or all disks."
    echo
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        SIZE=$(lsblk -n -o SIZE "$disk" | head -1)
        MODEL=$(lsblk -n -o MODEL "$disk" | head -1 | xargs)
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Disk: $disk"
        echo "Size: $SIZE"
        [ -n "$MODEL" ] && echo "Model: $MODEL"
        echo
        
        if prompt_confirm "Use this disk for storage?"; then
            SELECTED_DISKS+=("$disk")
            print_success "✓ $disk added to selection"
        else
            print_info "✗ $disk skipped"
        fi
        echo
    done
    
    if [ ${#SELECTED_DISKS[@]} -eq 0 ]; then
        print_warning "No disks selected!"
        echo
        if prompt_confirm "Go back to disk selection menu?"; then
            select_disks_for_setup
        else
            print_info "Skipping disk setup."
        fi
        return
    fi
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print_success "Selected ${#SELECTED_DISKS[@]} disk(s) for storage:"
    for disk in "${SELECTED_DISKS[@]}"; do
        SIZE=$(lsblk -n -o SIZE "$disk" | head -1)
        echo "  ✓ $disk ($SIZE)"
    done
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo
    
    if prompt_confirm "Proceed with these selected disks?"; then
        # Replace UNMOUNTED_DISKS with SELECTED_DISKS for setup
        UNMOUNTED_DISKS=("${SELECTED_DISKS[@]}")
        setup_disks
    else
        print_info "Cancelled. Going back to selection menu."
        select_disks_for_setup
    fi
}

setup_disks() {
    print_header "Disk Setup"
    
    echo "========================================================"
    echo "  STORAGE CONFIGURATION - Choose Your Setup"
    echo "========================================================"
    echo
    echo "💡 GUIDE: Which option do I need?"
    echo
    echo "For MOST users (apps, databases, file storage):"
    echo "  → Choose Option 1 (Longhorn)"
    echo "    - Automatic redundancy across nodes"
    echo "    - Works with your applications (databases, uploads, etc.)"
    echo "    - Most flexible option"
    echo
    echo "For S3-compatible object storage (backups, media, large files):"
    echo "  → Choose BOTH Option 1 (Longhorn) AND install MinIO later"
    echo "    - Longhorn for apps, MinIO for S3 storage"
    echo "    - You can add MinIO anytime after installation"
    echo
    echo "For manual control over disks:"
    echo "  → Choose Option 3 (RAID) or 4 (Individual)"
    echo
    echo "========================================================"
    echo "STORAGE OPTIONS:"
    echo "========================================================"
    echo
    echo "1) Longhorn Storage (RECOMMENDED for most users)"
    echo "   ✅ Automatic replication across nodes"
    echo "   ✅ Works with databases, apps, persistent storage"
    echo "   ✅ Easy to manage, no manual configuration"
    echo "   ✅ Best for: Running applications"
    echo
    echo "2) MinIO Storage (S3-compatible - Advanced users)"
    echo "   ⚠️  NOT for application storage"
    echo "   ✅ S3-compatible API (like Amazon S3)"
    echo "   ✅ Best for: Backups, media files, object storage"
    echo "   ⚠️  Most users should choose Longhorn + install MinIO later"
    echo
    echo "3) RAID Array (Manual redundancy)"
    echo "   ⚠️  Requires 2+ disks"
    echo "   ⚠️  Less flexible than Longhorn"
    echo "   ✅ Best for: Single-node setups, manual control"
    echo
    echo "4) Individual Mounts (No redundancy)"
    echo "   ⚠️  Each disk separate, no protection"
    echo "   ✅ Best for: Testing, temporary storage"
    echo
    echo "5) Skip disk setup (Configure later)"
    echo
    echo "========================================================"
    echo
    
    read -p "$(echo -e ${GREEN}?${NC}) Select option (1-5): " DISK_OPTION
    
    case $DISK_OPTION in
        1)
            setup_longhorn_disks
            ;;
        2)
            setup_minio_disks
            ;;
        3)
            setup_raid_array
            ;;
        4)
            setup_individual_mounts
            ;;
        5)
            print_info "Skipping disk setup"
            ;;
        *)
            print_error "Invalid option"
            setup_disks
            ;;
    esac
}

warn_data_loss() {
    local disk="$1"
    
    echo
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${RED}⚠️  WARNING: DATA LOSS RISK! ⚠️${NC}"
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${YELLOW}Formatting $disk will PERMANENTLY ERASE ALL DATA on it!${NC}"
    echo
    
    # Check if disk has filesystem
    if blkid "$disk" &> /dev/null; then
        local fstype=$(blkid -s TYPE -o value "$disk" 2>/dev/null || echo "unknown")
        echo -e "${YELLOW}This disk currently has: $fstype filesystem${NC}"
        echo
        
        if prompt_confirm "Show files on this disk before formatting?"; then
            local temp_mount="/tmp/mynodeone-check-$$"
            mkdir -p "$temp_mount"
            echo "Attempting to mount and show contents..."
            if mount -o ro "$disk" "$temp_mount" 2>/dev/null; then
                echo
                echo "Files/folders found on $disk:"
                ls -lh "$temp_mount" 2>/dev/null | head -20 || echo "Could not list files"
                umount "$temp_mount"
                echo
            else
                echo "Could not mount disk to show contents (may be encrypted or corrupted)"
            fi
            rmdir "$temp_mount" 2>/dev/null || true
        fi
    fi
    
    echo
    echo -e "${RED}⚠️  ALL DATA WILL BE LOST! ⚠️${NC}"
    echo
    echo "To confirm, type the disk name exactly: $(basename $disk)"
    read -p "> " confirm
    
    if [ "$confirm" != "$(basename $disk)" ]; then
        print_warning "Confirmation failed. Skipping this disk."
        return 1
    fi
    
    echo
    if ! prompt_confirm "Final confirmation - ERASE ALL DATA on $disk?"; then
        print_info "Skipping $disk"
        return 1
    fi
    
    return 0
}

prepare_disk_for_format() {
    local disk="$1"
    
    print_info "Preparing $disk for formatting..."
    
    # Step 1: Unmount all partitions on this disk
    print_info "Unmounting any mounted partitions on $disk..."
    
    # Get disk name without /dev/ prefix
    local disk_name=$(basename "$disk")
    
    # Find and unmount all partitions
    local unmount_failed=false
    while IFS= read -r partition; do
        if [ -n "$partition" ]; then
            print_info "  Unmounting $partition..."
            if ! umount "$partition" 2>/dev/null; then
                # Try force unmount
                if ! umount -f "$partition" 2>/dev/null; then
                    # Try lazy unmount as last resort
                    if ! umount -l "$partition" 2>/dev/null; then
                        print_warning "  Could not unmount $partition (may not be mounted)"
                    fi
                fi
            fi
        fi
    done < <(lsblk -ln -o NAME,TYPE "$disk" | awk '$2=="part" {print "/dev/"$1}')
    
    # Step 2: Wipe filesystem signatures and partition table
    print_info "Wiping filesystem signatures and partition table..."
    
    # Wipe all filesystem, raid, and partition-table signatures
    if command -v wipefs &> /dev/null; then
        if wipefs -a "$disk" 2>/dev/null; then
            print_success "  Disk signatures wiped successfully"
        else
            print_warning "  wipefs failed, trying dd method..."
            # Fallback: zero out first 1MB and last 1MB
            dd if=/dev/zero of="$disk" bs=1M count=1 2>/dev/null
            print_success "  Disk cleared with dd"
        fi
    else
        # wipefs not available, use dd
        print_info "  Using dd to clear disk..."
        dd if=/dev/zero of="$disk" bs=1M count=1 2>/dev/null
        print_success "  Disk cleared with dd"
    fi
    
    # Step 3: Inform kernel of partition table changes
    if command -v partprobe &> /dev/null; then
        partprobe "$disk" 2>/dev/null
    fi
    
    # Wait a moment for changes to take effect
    sleep 1
    
    print_success "Disk $disk prepared and ready for formatting"
    return 0
}

setup_longhorn_disks() {
    print_info "Setting up disks for Longhorn..."
    
    # Create Longhorn data directory
    LONGHORN_DIR="/mnt/longhorn-disks"
    mkdir -p "$LONGHORN_DIR"
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        print_info "Processing $disk..."
        
        # CRITICAL SAFETY CHECK: Never format OS disk
        if [ "$disk" = "$OS_DISK" ]; then
            print_error "CRITICAL: Attempted to format OS disk $disk - BLOCKED!"
            print_error "This disk contains your Ubuntu installation. Skipping."
            continue
        fi
        
        # Warn about data loss
        if ! warn_data_loss "$disk"; then
            continue
        fi
        
        # Prepare disk for formatting (unmount partitions, wipe signatures)
        if ! prepare_disk_for_format "$disk"; then
            print_error "Failed to prepare $disk for formatting"
            continue
        fi
        
        # Format as ext4 with optimization for large disks
        print_info "Formatting $disk as ext4 (optimized for large storage)..."
        CRITICAL_OPERATION=true
        
        # Get disk size in GB
        DISK_SIZE_GB=$(lsblk -b -n -d -o SIZE "$disk" | awk '{print int($1/1024/1024/1024)}')
        
        # Optimize formatting based on disk size
        if [ "$DISK_SIZE_GB" -gt 1000 ]; then
            # Large disk (>1TB): Reduce reserved blocks from 5% to 1%
            # For 18TB: Saves 720GB! (5% = 900GB, 1% = 180GB)
            print_info "  Large disk detected (${DISK_SIZE_GB}GB) - optimizing for maximum usable space..."
            if ! mkfs.ext4 -F -m 1 -T largefile4 "$disk"; then
                print_error "Failed to format $disk"
                CRITICAL_OPERATION=false
                continue
            fi
        else
            # Normal disk: Standard formatting
            if ! mkfs.ext4 -F "$disk"; then
                print_error "Failed to format $disk"
                CRITICAL_OPERATION=false
                continue
            fi
        fi
        CRITICAL_OPERATION=false
        
        # Get UUID
        UUID=$(blkid -s UUID -o value "$disk")
        
        if [ -z "$UUID" ]; then
            print_error "Failed to get UUID for $disk"
            continue
        fi
        
        # Create mount point
        MOUNT_POINT="$LONGHORN_DIR/disk-$(basename $disk)"
        mkdir -p "$MOUNT_POINT"
        
        # Add to fstab (avoid duplicates)
        if ! grep -q "$UUID" /etc/fstab; then
            echo "UUID=$UUID $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab
            print_success "Added to /etc/fstab"
        else
            print_warning "Already in /etc/fstab"
        fi
        
        # Mount
        if mount "$MOUNT_POINT" 2>/dev/null; then
            print_success "Mounted $disk at $MOUNT_POINT"
        else
            print_error "Failed to mount $disk"
            continue
        fi
    done
    
    # Save to config
    STORAGE_PATH="$LONGHORN_DIR"
    print_success "Longhorn storage configured at: $STORAGE_PATH"
}

setup_minio_disks() {
    print_info "Setting up disks for MinIO..."
    
    MINIO_DIR="/mnt/minio-disks"
    mkdir -p "$MINIO_DIR"
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        print_info "Processing $disk..."
        
        # CRITICAL SAFETY CHECK: Never format OS disk
        if [ "$disk" = "$OS_DISK" ]; then
            print_error "CRITICAL: Attempted to format OS disk $disk - BLOCKED!"
            print_error "This disk contains your Ubuntu installation. Skipping."
            continue
        fi
        
        # Warn about data loss
        if ! warn_data_loss "$disk"; then
            continue
        fi
        
        # Prepare disk for formatting (unmount partitions, wipe signatures)
        if ! prepare_disk_for_format "$disk"; then
            print_error "Failed to prepare $disk for formatting"
            continue
        fi
        
        # Format as ext4 with optimization for large disks
        print_info "Formatting $disk as ext4 (optimized for large storage)..."
        
        # Get disk size in GB
        DISK_SIZE_GB=$(lsblk -b -n -d -o SIZE "$disk" | awk '{print int($1/1024/1024/1024)}')
        
        # Optimize formatting based on disk size
        if [ "$DISK_SIZE_GB" -gt 1000 ]; then
            # Large disk (>1TB): Reduce reserved blocks from 5% to 1%
            print_info "  Large disk detected (${DISK_SIZE_GB}GB) - optimizing for maximum usable space..."
            if ! mkfs.ext4 -F -m 1 -T largefile4 "$disk"; then
                print_error "Failed to format $disk"
                continue
            fi
        else
            # Normal disk: Standard formatting
            if ! mkfs.ext4 -F "$disk"; then
                print_error "Failed to format $disk"
                continue
            fi
        fi
        
        UUID=$(blkid -s UUID -o value "$disk")
        
        if [ -z "$UUID" ]; then
            print_error "Failed to get UUID for $disk"
            continue
        fi
        
        MOUNT_POINT="$MINIO_DIR/disk-$(basename $disk)"
        mkdir -p "$MOUNT_POINT"
        
        # Add to fstab (avoid duplicates)
        if ! grep -q "$UUID" /etc/fstab; then
            echo "UUID=$UUID $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab
            print_success "Added to /etc/fstab"
        else
            print_warning "Already in /etc/fstab"
        fi
        
        if mount "$MOUNT_POINT" 2>/dev/null; then
            print_success "Mounted $disk at $MOUNT_POINT"
        else
            print_error "Failed to mount $disk"
            continue
        fi
    done
    
    STORAGE_PATH="$MINIO_DIR"
    print_success "MinIO storage configured at: $STORAGE_PATH"
}

setup_raid_array() {
    print_info "Setting up RAID array..."
    
    if [ ${#UNMOUNTED_DISKS[@]} -lt 2 ]; then
        print_error "RAID requires at least 2 disks"
        return
    fi
    
    # Check if RAID device already exists
    if [ -e /dev/md0 ]; then
        print_error "RAID device /dev/md0 already exists!"
        echo
        echo "Existing RAID configuration:"
        cat /proc/mdstat 2>/dev/null || echo "Could not read /proc/mdstat"
        echo
        if [ -f /etc/mdadm/mdadm.conf ]; then
            echo "Existing arrays in mdadm.conf:"
            grep "^ARRAY" /etc/mdadm/mdadm.conf || echo "No arrays configured"
        fi
        echo
        print_error "Cannot create RAID - /dev/md0 is in use"
        echo "Options:"
        echo "  1. Use a different RAID device number (edit script)"
        echo "  2. Remove existing RAID: mdadm --stop /dev/md0"
        echo "  3. Choose a different storage option"
        return 1
    fi
    
    # Install mdadm
    print_info "Installing mdadm..."
    if ! apt-get install -y mdadm; then
        print_error "Failed to install mdadm"
        return 1
    fi
    
    echo "Select RAID level:"
    echo "1) RAID 0 (Striping - Best performance, no redundancy)"
    echo "2) RAID 1 (Mirroring - Redundancy, half capacity)"
    echo "3) RAID 5 (Distributed parity - Good balance, requires 3+ disks)"
    echo "4) RAID 10 (Mirrored stripes - Best of both, requires 4+ disks)"
    
    read -p "Select RAID level: " RAID_LEVEL
    
    case $RAID_LEVEL in
        1)
            RAID_TYPE="0"
            ;;
        2)
            RAID_TYPE="1"
            ;;
        3)
            if [ ${#UNMOUNTED_DISKS[@]} -lt 3 ]; then
                print_error "RAID 5 requires at least 3 disks"
                return
            fi
            RAID_TYPE="5"
            ;;
        4)
            if [ ${#UNMOUNTED_DISKS[@]} -lt 4 ]; then
                print_error "RAID 10 requires at least 4 disks"
                return
            fi
            RAID_TYPE="10"
            ;;
        *)
            print_error "Invalid RAID level"
            return
            ;;
    esac
    
    # Create RAID array
    print_info "Creating RAID $RAID_TYPE array..."
    mdadm --create /dev/md0 --level=$RAID_TYPE --raid-devices=${#UNMOUNTED_DISKS[@]} "${UNMOUNTED_DISKS[@]}"
    
    # Format RAID array with optimization
    print_info "Formatting RAID array..."
    
    # Get total RAID size in GB
    RAID_SIZE_GB=$(lsblk -b -n -d -o SIZE /dev/md0 2>/dev/null | awk '{print int($1/1024/1024/1024)}')
    
    if [ -n "$RAID_SIZE_GB" ] && [ "$RAID_SIZE_GB" -gt 1000 ]; then
        # Large RAID (>1TB): Optimize for large storage
        print_info "  Large RAID array detected (${RAID_SIZE_GB}GB) - optimizing..."
        mkfs.ext4 -F -m 1 -T largefile4 /dev/md0
    else
        # Normal RAID: Standard formatting
        mkfs.ext4 -F /dev/md0
    fi
    
    # Mount
    mkdir -p /mnt/raid0
    mount /dev/md0 /mnt/raid0
    
    # Add to fstab
    echo "/dev/md0 /mnt/raid0 ext4 defaults 0 2" >> /etc/fstab
    
    # Backup mdadm.conf if it exists
    if [ -f /etc/mdadm/mdadm.conf ]; then
        cp /etc/mdadm/mdadm.conf "/etc/mdadm/mdadm.conf.backup-$(date +%Y%m%d-%H%M%S)"
        print_success "Backed up existing mdadm.conf"
    fi
    
    # Save RAID config
    print_info "Saving RAID configuration..."
    mdadm --detail --scan >> /etc/mdadm/mdadm.conf
    
    if command -v update-initramfs &> /dev/null; then
        print_info "Updating initramfs..."
        update-initramfs -u
    fi
    
    STORAGE_PATH="/mnt/raid0"
    print_success "RAID array created and mounted at: $STORAGE_PATH"
}

setup_individual_mounts() {
    print_info "Setting up individual disk mounts..."
    
    STORAGE_DIR="/mnt/storage"
    mkdir -p "$STORAGE_DIR"
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        print_info "Processing $disk..."
        
        # CRITICAL SAFETY CHECK: Never format OS disk
        if [ "$disk" = "$OS_DISK" ]; then
            print_error "CRITICAL: Attempted to format OS disk $disk - BLOCKED!"
            print_error "This disk contains your Ubuntu installation. Skipping."
            continue
        fi
        
        # Warn about data loss
        if ! warn_data_loss "$disk"; then
            continue
        fi
        
        # Prepare disk for formatting (unmount partitions, wipe signatures)
        if ! prepare_disk_for_format "$disk"; then
            print_error "Failed to prepare $disk for formatting"
            continue
        fi
        
        # Format as ext4 with optimization for large disks
        print_info "Formatting $disk as ext4 (optimized for large storage)..."
        
        # Get disk size in GB
        DISK_SIZE_GB=$(lsblk -b -n -d -o SIZE "$disk" | awk '{print int($1/1024/1024/1024)}')
        
        # Optimize formatting based on disk size
        if [ "$DISK_SIZE_GB" -gt 1000 ]; then
            # Large disk (>1TB): Reduce reserved blocks from 5% to 1%
            print_info "  Large disk detected (${DISK_SIZE_GB}GB) - optimizing for maximum usable space..."
            if ! mkfs.ext4 -F -m 1 -T largefile4 "$disk"; then
                print_error "Failed to format $disk"
                continue
            fi
        else
            # Normal disk: Standard formatting
            if ! mkfs.ext4 -F "$disk"; then
                print_error "Failed to format $disk"
                continue
            fi
        fi
        
        UUID=$(blkid -s UUID -o value "$disk")
        
        if [ -z "$UUID" ]; then
            print_error "Failed to get UUID for $disk"
            continue
        fi
        
        MOUNT_POINT="$STORAGE_DIR/$(basename $disk)"
        mkdir -p "$MOUNT_POINT"
        
        # Add to fstab (avoid duplicates)
        if ! grep -q "$UUID" /etc/fstab; then
            echo "UUID=$UUID $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab
            print_success "Added to /etc/fstab"
        else
            print_warning "Already in /etc/fstab"
        fi
        
        if mount "$MOUNT_POINT" 2>/dev/null; then
            print_success "Mounted $disk at $MOUNT_POINT"
        else
            print_error "Failed to mount $disk"
            continue
        fi
    done
    
    STORAGE_PATH="$STORAGE_DIR"
    print_success "Individual disks mounted at: $STORAGE_PATH"
}

# Functions removed - interactive-setup.sh now handles node type selection
# The old flow was confusing (asked twice for node type)

show_documentation_info() {
    print_header "Documentation & Help"
    
    echo "📚 Documentation is available at:"
    echo
    echo "  • Installation Guide: $PROJECT_ROOT/INSTALLATION.md"
    echo "  • Getting Started: $PROJECT_ROOT/GETTING-STARTED.md"
    echo "  • Architecture: $PROJECT_ROOT/docs/architecture.md"
    echo "  • Operations: $PROJECT_ROOT/docs/operations.md"
    echo "  • FAQ: $PROJECT_ROOT/FAQ.md"
    echo
    echo "🌐 Web UI will be available after installation:"
    echo "  • Grafana (Monitoring): http://<control-plane-ip>:3000"
    echo "  • ArgoCD (GitOps): https://<control-plane-ip>:8080"
    echo "  • MinIO (S3 Storage): http://<control-plane-ip>:9000"
    echo
    echo "📖 For detailed storage and setup options, see:"
    echo "  • Storage Options: $PROJECT_ROOT/docs/storage-guide.md"
    echo "  • Setup Options: $PROJECT_ROOT/docs/setup-options-guide.md"
    echo
}

main() {
    welcome
    check_root
    
    # Pre-flight checks
    print_header "Pre-Flight Checks"
    check_dependencies || exit 1
    check_architecture
    check_distro
    
    system_cleanup
    
    # Show documentation FIRST so users know what's coming
    show_documentation_info
    
    # Run interactive setup wizard to get configuration
    print_header "Configuration Wizard"
    print_info "This wizard will help you configure your node..."
    echo
    
    if ! prompt_confirm "Ready to start the configuration wizard?"; then
        print_info "Installation cancelled."
        exit 0
    fi
    
    # Call interactive setup - it handles node type selection
    bash "$SCRIPT_DIR/interactive-setup.sh"
    
    # Load the configuration created by interactive setup
    CONFIG_FILE="$HOME/.mynodeone/config.env"
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    else
        print_error "Configuration file not found. Setup may have failed."
        exit 1
    fi
    
    # Now do disk detection and setup if this is a storage node
    if [ "$NODE_TYPE" = "control-plane" ] || [ "$NODE_TYPE" = "worker" ]; then
        detect_disks
        
        # Now let user configure disks interactively
        if [ ${#UNMOUNTED_DISKS[@]} -gt 0 ]; then
            echo
            print_info "Found ${#UNMOUNTED_DISKS[@]} disk(s) available for storage."
            echo
            if prompt_confirm "Do you want to set up these disks for MyNodeOne storage?"; then
                select_disks_for_setup
            else
                print_info "Skipping disk setup. You can configure storage later."
            fi
        else
            print_warning "No additional disks detected for storage setup."
            print_info "Storage will use the OS disk (not recommended for production)."
        fi
    fi
    
    echo
    print_success "Configuration complete!"
    echo
    
    # Proceed with installation
    if prompt_confirm "Proceed with installation?"; then
        case "$NODE_TYPE" in
            control-plane)
                print_info "Running control plane bootstrap..."
                bash "$SCRIPT_DIR/bootstrap-control-plane.sh"
                ;;
            worker)
                print_info "Running worker node setup..."
                bash "$SCRIPT_DIR/add-worker-node.sh"
                ;;
            edge)
                print_info "Running edge node setup..."
                bash "$SCRIPT_DIR/setup-edge-node.sh"
                ;;
            management)
                print_success "Management workstation configured!"
                print_info "Follow the instructions above to set up kubectl."
                exit 0
                ;;
            *)
                print_error "Unknown node type: $NODE_TYPE"
                exit 1
                ;;
        esac
        
        echo
        print_header "Installation Complete!"
        print_success "Your MyNodeOne node has been set up successfully! 🎉"
        echo
        echo "Next steps:"
        echo "  1. Review credentials in /root/mynodeone-*-credentials.txt"
        echo "  2. Check status: kubectl get nodes"
        echo "  3. Deploy apps: kubectl apply -f manifests/examples/"
        echo
    else
        print_info "Installation cancelled. Configuration saved in $CONFIG_FILE"
        print_info "Run this script again to install."
        exit 0
    fi
}

# Run main function
main "$@"
