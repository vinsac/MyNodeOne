#!/bin/bash

###############################################################################
# NodeZero - Main Installation Script
# 
# This is the ONE script users run. It handles everything:
# - System cleanup
# - Disk detection and setup
# - Interactive configuration
# - Node type selection
# - Automated deployment
###############################################################################

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Track if we're in the middle of critical operations
CRITICAL_OPERATION=false

# Cleanup function for interrupt handling
cleanup_on_interrupt() {
    echo
    echo
    print_error "Installation interrupted by user (Ctrl+C)"
    echo
    
    if [ "$CRITICAL_OPERATION" = true ]; then
        print_warning "Interrupted during a critical operation!"
        echo "Your system may be in an inconsistent state."
        echo
        echo "To recover:"
        echo "  1. Check what was being done (see messages above)"
        echo "  2. Manually undo any partial changes if needed"
        echo "  3. Run the script again to restart"
    else
        print_info "No critical operations were in progress."
        echo "You can safely run the script again."
    fi
    
    echo
    exit 130
}

# Set up interrupt handling
trap cleanup_on_interrupt INT TERM

# Helper functions
print_header() {
    echo
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

prompt_confirm() {
    local prompt="$1"
    local default="${2:-n}"
    local response
    
    if [ "$default" = "y" ]; then
        read -p "$(echo -e ${GREEN}?${NC}) $prompt [Y/n]: " response
        response="${response:-y}"
    else
        read -p "$(echo -e ${GREEN}?${NC}) $prompt [y/N]: " response
        response="${response:-n}"
    fi
    
    [[ "$response" =~ ^[Yy]$ ]]
}

welcome() {
    clear
    echo -e "${MAGENTA}"
    cat << "EOF"
    _   __          __     ______                
   / | / /___  ____/ /__  /__  (_)___  _________
  /  |/ / __ \/ __  / _ \   / / / _ \/ ___/ __ \
 / /|  / /_/ / /_/ /  __/  / /_/  __/ /  / /_/ /
/_/ |_/\____/\__,_/\___/  /___/\___/_/   \____/ 
                                                 
EOF
    echo -e "${NC}"
    echo -e "${CYAN}Welcome to NodeZero Setup!${NC}"
    echo
    echo "This script will help you set up your private cloud infrastructure."
    echo "It handles everything automatically:"
    echo
    echo "  ✓ System optimization"
    echo "  ✓ Disk detection and setup"
    echo "  ✓ Network configuration"
    echo "  ✓ Service installation"
    echo
    echo -e "${YELLOW}Note: This script requires sudo/root access.${NC}"
    echo
    
    if ! prompt_confirm "Ready to start?" "y"; then
        echo "Setup cancelled."
        exit 0
    fi
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        print_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

check_network() {
    print_info "Checking internet connectivity..."
    
    if ! ping -c 1 -W 5 8.8.8.8 &> /dev/null; then
        print_error "No internet connection detected"
        echo
        echo "NodeZero requires internet access to download components."
        echo "Please check your network connection and try again."
        echo
        echo "Troubleshooting:"
        echo "  1. Check if network cable is connected"
        echo "  2. Try: ping 8.8.8.8"
        echo "  3. Check firewall settings"
        return 1
    fi
    
    if ! ping -c 1 -W 5 github.com &> /dev/null; then
        print_warning "Can reach internet but not GitHub"
        echo "This might cause issues downloading from GitHub."
        if ! prompt_confirm "Continue anyway?"; then
            return 1
        fi
    fi
    
    print_success "Internet connection OK"
    return 0
}

check_dependencies() {
    print_info "Checking required dependencies..."
    
    local deps=("curl" "wget" "git" "lsblk" "mkfs.ext4" "blkid" "awk" "grep")
    local missing=()
    
    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        print_error "Missing required dependencies: ${missing[*]}"
        echo
        echo "Install with:"
        echo "  sudo apt-get update"
        echo "  sudo apt-get install -y ${missing[*]}"
        return 1
    fi
    
    print_success "All dependencies present"
    return 0
}

check_system_resources() {
    print_info "Validating system resources..."
    
    # Check RAM
    local ram_gb=$(free -g | awk '/^Mem:/{print $2}')
    local min_ram=4
    
    if [ "$ram_gb" -lt "$min_ram" ]; then
        print_error "Insufficient RAM: ${ram_gb}GB (minimum ${min_ram}GB required for control plane)"
        echo
        echo "Your system has ${ram_gb}GB RAM, but control plane requires at least ${min_ram}GB."
        echo
        echo "Options:"
        echo "  1. Add more RAM to this machine"
        echo "  2. Use this as a worker node instead (requires 2GB minimum)"
        echo "  3. Use a different machine with more RAM"
        return 1
    fi
    
    # Check disk space
    local disk_gb=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
    local min_disk=20
    
    if [ "$disk_gb" -lt "$min_disk" ]; then
        print_error "Insufficient disk space: ${disk_gb}GB available (minimum ${min_disk}GB required)"
        echo
        echo "Free up space with:"
        echo "  sudo apt-get clean"
        echo "  sudo apt-get autoremove"
        echo "  sudo journalctl --vacuum-time=7d"
        echo
        return 1
    fi
    
    # Check CPU cores
    local cpu_cores=$(nproc)
    local min_cores=2
    
    if [ "$cpu_cores" -lt "$min_cores" ]; then
        print_warning "Low CPU cores: ${cpu_cores} (recommended ${min_cores}+ for smooth operation)"
        echo "Installation will proceed but performance may be limited."
        if ! prompt_confirm "Continue anyway?"; then
            return 1
        fi
    fi
    
    print_success "System resources OK: ${ram_gb}GB RAM, ${disk_gb}GB free disk, ${cpu_cores} CPU cores"
    return 0
}

check_existing_installation() {
    if [ -f "$HOME/.nodezero/config.env" ]; then
        print_warning "NodeZero appears to be already configured"
        echo
        echo "Existing configuration found at: $HOME/.nodezero/config.env"
        echo
        echo "Options:"
        echo "  1) Reconfigure (update configuration, keep existing setup)"
        echo "  2) Reinstall (remove everything, fresh start)"
        echo "  3) Cancel"
        echo
        read -p "Select option (1-3): " option
        
        case $option in
            1)
                print_info "Reconfiguring..."
                return 0
                ;;
            2)
                print_warning "This will remove existing NodeZero installation"
                if prompt_confirm "Are you sure you want to reinstall?"; then
                    # Backup existing config
                    cp "$HOME/.nodezero/config.env" "$HOME/.nodezero/config.env.backup-$(date +%Y%m%d-%H%M%S)"
                    print_info "Config backed up. Proceeding with reinstall..."
                    return 0
                else
                    exit 0
                fi
                ;;
            3)
                print_info "Installation cancelled"
                exit 0
                ;;
            *)
                print_error "Invalid option"
                exit 1
                ;;
        esac
    fi
}

system_cleanup() {
    print_header "System Cleanup & Optimization"
    
    if prompt_confirm "Clean up unnecessary packages?"; then
        print_info "Removing unnecessary packages..."
        
        # Remove snap if not needed (controversial, but saves resources)
        if command -v snap &> /dev/null; then
            if prompt_confirm "Remove Snap (saves 500MB+ RAM)?"; then
                print_info "Removing Snap packages..."
                snap list | awk 'NR>1 {print $1}' | xargs -I {} snap remove {} 2>/dev/null || true
                apt-get purge -y snapd 2>/dev/null || true
                rm -rf /snap /var/snap /var/lib/snapd
                print_success "Snap removed"
            fi
        fi
        
        # Remove unnecessary packages
        print_info "Removing unnecessary packages..."
        apt-get autoremove -y
        apt-get autoclean -y
        
        # Clean apt cache
        apt-get clean
        
        # Remove old kernels (keep current + 1)
        print_info "Cleaning old kernels..."
        apt-get autoremove --purge -y
        
        print_success "System cleanup complete"
    else
        print_info "Skipping system cleanup"
    fi
}

detect_disks() {
    print_header "Disk Detection"
    
    print_info "Scanning for available disks..."
    echo
    
    # List all block devices
    lsblk -o NAME,SIZE,TYPE,MOUNTPOINT,FSTYPE | grep -E "disk|part"
    echo
    
    # Detect unmounted disks
    UNMOUNTED_DISKS=()
    while IFS= read -r line; do
        DISK=$(echo "$line" | awk '{print $1}')
        MOUNTPOINT=$(echo "$line" | awk '{print $4}')
        
        if [ -z "$MOUNTPOINT" ] && [[ "$DISK" =~ ^sd[b-z]$|^nvme[1-9]n[0-9]$ ]]; then
            UNMOUNTED_DISKS+=("/dev/$DISK")
        fi
    done < <(lsblk -n -o NAME,MOUNTPOINT | grep -v "^loop")
    
    if [ ${#UNMOUNTED_DISKS[@]} -eq 0 ]; then
        print_info "No unmounted disks detected."
        return
    fi
    
    print_warning "Found ${#UNMOUNTED_DISKS[@]} unmounted disk(s):"
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        SIZE=$(lsblk -n -o SIZE "$disk" | head -1)
        echo "  • $disk ($SIZE)"
    done
    echo
    
    if prompt_confirm "Do you want to set up these disks for NodeZero storage?"; then
        setup_disks
    fi
}

setup_disks() {
    print_header "Disk Setup"
    
    echo "How would you like to use the unmounted disks?"
    echo
    echo "1) Longhorn Storage (Recommended - Distributed block storage)"
    echo "2) MinIO Storage (S3-compatible object storage)"
    echo "3) RAID Array (Combine multiple disks)"
    echo "4) Individual Mounts (Mount each disk separately)"
    echo "5) Skip disk setup"
    echo
    
    read -p "$(echo -e ${GREEN}?${NC}) Select option (1-5): " DISK_OPTION
    
    case $DISK_OPTION in
        1)
            setup_longhorn_disks
            ;;
        2)
            setup_minio_disks
            ;;
        3)
            setup_raid_array
            ;;
        4)
            setup_individual_mounts
            ;;
        5)
            print_info "Skipping disk setup"
            ;;
        *)
            print_error "Invalid option"
            setup_disks
            ;;
    esac
}

warn_data_loss() {
    local disk="$1"
    
    echo
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${RED}⚠️  WARNING: DATA LOSS RISK! ⚠️${NC}"
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${YELLOW}Formatting $disk will PERMANENTLY ERASE ALL DATA on it!${NC}"
    echo
    
    # Check if disk has filesystem
    if blkid "$disk" &> /dev/null; then
        local fstype=$(blkid -s TYPE -o value "$disk" 2>/dev/null || echo "unknown")
        echo -e "${YELLOW}This disk currently has: $fstype filesystem${NC}"
        echo
        
        if prompt_confirm "Show files on this disk before formatting?"; then
            local temp_mount="/tmp/nodezero-check-$$"
            mkdir -p "$temp_mount"
            echo "Attempting to mount and show contents..."
            if mount -o ro "$disk" "$temp_mount" 2>/dev/null; then
                echo
                echo "Files/folders found on $disk:"
                ls -lh "$temp_mount" 2>/dev/null | head -20 || echo "Could not list files"
                umount "$temp_mount"
                echo
            else
                echo "Could not mount disk to show contents (may be encrypted or corrupted)"
            fi
            rmdir "$temp_mount" 2>/dev/null || true
        fi
    fi
    
    echo
    echo -e "${RED}⚠️  ALL DATA WILL BE LOST! ⚠️${NC}"
    echo
    echo "To confirm, type the disk name exactly: $(basename $disk)"
    read -p "> " confirm
    
    if [ "$confirm" != "$(basename $disk)" ]; then
        print_warning "Confirmation failed. Skipping this disk."
        return 1
    fi
    
    echo
    if ! prompt_confirm "Final confirmation - ERASE ALL DATA on $disk?"; then
        print_info "Skipping $disk"
        return 1
    fi
    
    return 0
}

setup_longhorn_disks() {
    print_info "Setting up disks for Longhorn..."
    
    # Create Longhorn data directory
    LONGHORN_DIR="/mnt/longhorn-disks"
    mkdir -p "$LONGHORN_DIR"
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        print_info "Processing $disk..."
        
        # Warn about data loss
        if ! warn_data_loss "$disk"; then
            continue
        fi
        
        # Format as ext4 (show errors, don't hide them)
        print_info "Formatting $disk as ext4..."
        CRITICAL_OPERATION=true
        if ! mkfs.ext4 -F "$disk"; then
            print_error "Failed to format $disk"
            CRITICAL_OPERATION=false
            continue
        fi
        CRITICAL_OPERATION=false
        
        # Get UUID
        UUID=$(blkid -s UUID -o value "$disk")
        
        if [ -z "$UUID" ]; then
            print_error "Failed to get UUID for $disk"
            continue
        fi
        
        # Create mount point
        MOUNT_POINT="$LONGHORN_DIR/disk-$(basename $disk)"
        mkdir -p "$MOUNT_POINT"
        
        # Add to fstab (avoid duplicates)
        if ! grep -q "$UUID" /etc/fstab; then
            echo "UUID=$UUID $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab
            print_success "Added to /etc/fstab"
        else
            print_warning "Already in /etc/fstab"
        fi
        
        # Mount
        if mount "$MOUNT_POINT" 2>/dev/null; then
            print_success "Mounted $disk at $MOUNT_POINT"
        else
            print_error "Failed to mount $disk"
            continue
        fi
    done
    
    # Save to config
    STORAGE_PATH="$LONGHORN_DIR"
    print_success "Longhorn storage configured at: $STORAGE_PATH"
}

setup_minio_disks() {
    print_info "Setting up disks for MinIO..."
    
    MINIO_DIR="/mnt/minio-disks"
    mkdir -p "$MINIO_DIR"
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        print_info "Processing $disk..."
        
        # Warn about data loss
        if ! warn_data_loss "$disk"; then
            continue
        fi
        
        # Format as ext4 (show errors)
        print_info "Formatting $disk as ext4..."
        if ! mkfs.ext4 -F "$disk"; then
            print_error "Failed to format $disk"
            continue
        fi
        
        UUID=$(blkid -s UUID -o value "$disk")
        
        if [ -z "$UUID" ]; then
            print_error "Failed to get UUID for $disk"
            continue
        fi
        
        MOUNT_POINT="$MINIO_DIR/disk-$(basename $disk)"
        mkdir -p "$MOUNT_POINT"
        
        # Add to fstab (avoid duplicates)
        if ! grep -q "$UUID" /etc/fstab; then
            echo "UUID=$UUID $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab
            print_success "Added to /etc/fstab"
        else
            print_warning "Already in /etc/fstab"
        fi
        
        if mount "$MOUNT_POINT" 2>/dev/null; then
            print_success "Mounted $disk at $MOUNT_POINT"
        else
            print_error "Failed to mount $disk"
            continue
        fi
    done
    
    STORAGE_PATH="$MINIO_DIR"
    print_success "MinIO storage configured at: $STORAGE_PATH"
}

setup_raid_array() {
    print_info "Setting up RAID array..."
    
    if [ ${#UNMOUNTED_DISKS[@]} -lt 2 ]; then
        print_error "RAID requires at least 2 disks"
        return
    fi
    
    # Check if RAID device already exists
    if [ -e /dev/md0 ]; then
        print_error "RAID device /dev/md0 already exists!"
        echo
        echo "Existing RAID configuration:"
        cat /proc/mdstat 2>/dev/null || echo "Could not read /proc/mdstat"
        echo
        if [ -f /etc/mdadm/mdadm.conf ]; then
            echo "Existing arrays in mdadm.conf:"
            grep "^ARRAY" /etc/mdadm/mdadm.conf || echo "No arrays configured"
        fi
        echo
        print_error "Cannot create RAID - /dev/md0 is in use"
        echo "Options:"
        echo "  1. Use a different RAID device number (edit script)"
        echo "  2. Remove existing RAID: mdadm --stop /dev/md0"
        echo "  3. Choose a different storage option"
        return 1
    fi
    
    # Install mdadm
    print_info "Installing mdadm..."
    if ! apt-get install -y mdadm; then
        print_error "Failed to install mdadm"
        return 1
    fi
    
    echo "Select RAID level:"
    echo "1) RAID 0 (Striping - Best performance, no redundancy)"
    echo "2) RAID 1 (Mirroring - Redundancy, half capacity)"
    echo "3) RAID 5 (Distributed parity - Good balance, requires 3+ disks)"
    echo "4) RAID 10 (Mirrored stripes - Best of both, requires 4+ disks)"
    
    read -p "Select RAID level: " RAID_LEVEL
    
    case $RAID_LEVEL in
        1)
            RAID_TYPE="0"
            ;;
        2)
            RAID_TYPE="1"
            ;;
        3)
            if [ ${#UNMOUNTED_DISKS[@]} -lt 3 ]; then
                print_error "RAID 5 requires at least 3 disks"
                return
            fi
            RAID_TYPE="5"
            ;;
        4)
            if [ ${#UNMOUNTED_DISKS[@]} -lt 4 ]; then
                print_error "RAID 10 requires at least 4 disks"
                return
            fi
            RAID_TYPE="10"
            ;;
        *)
            print_error "Invalid RAID level"
            return
            ;;
    esac
    
    # Create RAID array
    print_info "Creating RAID $RAID_TYPE array..."
    mdadm --create /dev/md0 --level=$RAID_TYPE --raid-devices=${#UNMOUNTED_DISKS[@]} "${UNMOUNTED_DISKS[@]}"
    
    # Format
    mkfs.ext4 -F /dev/md0
    
    # Mount
    mkdir -p /mnt/raid0
    mount /dev/md0 /mnt/raid0
    
    # Add to fstab
    echo "/dev/md0 /mnt/raid0 ext4 defaults 0 2" >> /etc/fstab
    
    # Backup mdadm.conf if it exists
    if [ -f /etc/mdadm/mdadm.conf ]; then
        cp /etc/mdadm/mdadm.conf "/etc/mdadm/mdadm.conf.backup-$(date +%Y%m%d-%H%M%S)"
        print_success "Backed up existing mdadm.conf"
    fi
    
    # Save RAID config
    print_info "Saving RAID configuration..."
    mdadm --detail --scan >> /etc/mdadm/mdadm.conf
    
    if command -v update-initramfs &> /dev/null; then
        print_info "Updating initramfs..."
        update-initramfs -u
    fi
    
    STORAGE_PATH="/mnt/raid0"
    print_success "RAID array created and mounted at: $STORAGE_PATH"
}

setup_individual_mounts() {
    print_info "Setting up individual disk mounts..."
    
    STORAGE_DIR="/mnt/storage"
    mkdir -p "$STORAGE_DIR"
    
    for disk in "${UNMOUNTED_DISKS[@]}"; do
        print_info "Processing $disk..."
        
        # Warn about data loss
        if ! warn_data_loss "$disk"; then
            continue
        fi
        
        # Format as ext4 (show errors)
        print_info "Formatting $disk as ext4..."
        if ! mkfs.ext4 -F "$disk"; then
            print_error "Failed to format $disk"
            continue
        fi
        
        UUID=$(blkid -s UUID -o value "$disk")
        
        if [ -z "$UUID" ]; then
            print_error "Failed to get UUID for $disk"
            continue
        fi
        
        MOUNT_POINT="$STORAGE_DIR/$(basename $disk)"
        mkdir -p "$MOUNT_POINT"
        
        # Add to fstab (avoid duplicates)
        if ! grep -q "$UUID" /etc/fstab; then
            echo "UUID=$UUID $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab
            print_success "Added to /etc/fstab"
        else
            print_warning "Already in /etc/fstab"
        fi
        
        if mount "$MOUNT_POINT" 2>/dev/null; then
            print_success "Mounted $disk at $MOUNT_POINT"
        else
            print_error "Failed to mount $disk"
            continue
        fi
    done
    
    STORAGE_PATH="$STORAGE_DIR"
    print_success "Individual disks mounted at: $STORAGE_PATH"
}

select_node_type() {
    print_header "Node Type Selection"
    
    echo "What type of node do you want to set up?"
    echo
    echo "1) Control Plane Node"
    echo "   First node in your cluster. Runs Kubernetes master."
    echo "   Minimum: 4GB RAM, 20GB disk"
    echo "   Recommended: 8GB+ RAM, 100GB+ disk"
    echo
    echo "2) Worker Node"
    echo "   Additional compute node. Runs your applications."
    echo "   Minimum: 2GB RAM, 20GB disk"
    echo "   Recommended: 8GB+ RAM, 100GB+ disk"
    echo
    echo "3) VPS Edge Node"
    echo "   Public-facing reverse proxy on a VPS."
    echo "   Requires: Public IP, 1GB+ RAM"
    echo
    echo "4) Management Workstation"
    echo "   Your laptop/desktop for managing the cluster."
    echo "   Requires: kubectl installed"
    echo
    
    while true; do
        read -p "$(echo -e ${GREEN}?${NC}) Select node type (1-4): " NODE_TYPE_NUM
        
        case $NODE_TYPE_NUM in
            1)
                NODE_TYPE="control-plane"
                break
                ;;
            2)
                NODE_TYPE="worker"
                break
                ;;
            3)
                NODE_TYPE="edge"
                break
                ;;
            4)
                NODE_TYPE="management"
                break
                ;;
            *)
                print_error "Invalid selection. Please choose 1-4."
                ;;
        esac
    done
    
    print_success "Selected: $NODE_TYPE"
}

run_setup() {
    case $NODE_TYPE in
        control-plane|worker|edge)
            # Run interactive setup first
            print_info "Running configuration wizard..."
            bash "$SCRIPT_DIR/interactive-setup.sh"
            
            # Then run the appropriate installation script
            case $NODE_TYPE in
                control-plane)
                    print_info "Running control plane bootstrap..."
                    bash "$SCRIPT_DIR/bootstrap-control-plane.sh"
                    ;;
                worker)
                    print_info "Running worker node setup..."
                    bash "$SCRIPT_DIR/add-worker-node.sh"
                    ;;
                edge)
                    print_info "Running edge node setup..."
                    bash "$SCRIPT_DIR/setup-edge-node.sh"
                    ;;
            esac
            ;;
        management)
            # Just run interactive setup
            bash "$SCRIPT_DIR/interactive-setup.sh"
            ;;
    esac
}

show_documentation_info() {
    print_header "Documentation & Help"
    
    echo "📚 Documentation is available at:"
    echo
    echo "  • Quick Start: $PROJECT_ROOT/NEW-QUICKSTART.md"
    echo "  • Architecture: $PROJECT_ROOT/docs/architecture.md"
    echo "  • Operations: $PROJECT_ROOT/docs/operations.md"
    echo "  • FAQ: $PROJECT_ROOT/FAQ.md"
    echo
    echo "🌐 Web UI will be available after installation:"
    echo "  • Grafana (Monitoring): http://<control-plane-ip>:3000"
    echo "  • ArgoCD (GitOps): https://<control-plane-ip>:8080"
    echo "  • MinIO (S3 Storage): http://<control-plane-ip>:9000"
    echo
    echo "📖 For detailed explanations of each option, see:"
    echo "  $PROJECT_ROOT/docs/getting-started.md"
    echo
}

main() {
    welcome
    check_root
    
    # Pre-flight checks
    print_header "Pre-Flight Checks"
    check_dependencies || exit 1
    check_network || exit 1
    check_system_resources || exit 1
    check_existing_installation
    
    system_cleanup
    detect_disks
    select_node_type
    show_documentation_info
    
    echo
    if prompt_confirm "Ready to proceed with installation?" "y"; then
        run_setup
        
        print_header "Installation Complete!"
        print_success "Your NodeZero node has been set up successfully! 🎉"
        echo
        echo "Next steps:"
        echo "  1. Review the credentials in /root/nodezero-*-credentials.txt"
        echo "  2. Check status: kubectl get nodes"
        echo "  3. Deploy an application: kubectl apply -f manifests/examples/"
        echo
    else
        print_info "Installation cancelled."
    fi
}

# Run main function
main "$@"
